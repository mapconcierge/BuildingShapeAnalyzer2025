<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Building Shape Analysis Tool</title>
    <script src='https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js'></script>
    <link href='https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css' rel='stylesheet' />
    <script src='https://unpkg.com/@turf/turf@6.5.0/turf.min.js'></script>
    <script src='https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js'></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            overflow: hidden;
        }
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        .control-panel {
            position: absolute;
            top: 20px;
            right: 20px;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 400px;
            max-height: 90vh;
            overflow-y: auto;
            z-index: 1;
        }
        h1 {
            font-size: 18px;
            margin-bottom: 15px;
            color: #333;
        }
        h2 {
            font-size: 14px;
            margin-top: 15px;
            margin-bottom: 10px;
            color: #555;
        }
        .upload-section {
            margin-bottom: 15px;
        }
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
        }
        input[type="file"] {
            width: 100%;
            padding: 8px;
            border: 2px dashed #ccc;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }
        button {
            width: 100%;
            padding: 10px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin-top: 10px;
        }
        button:hover {
            background: #45a049;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
            margin-top: 10px;
        }
        .stats-table th,
        .stats-table td {
            padding: 6px;
            text-align: left;
            border-bottom: 1px solid #eee;
        }
        .stats-table th {
            background: #f5f5f5;
            font-weight: 600;
        }
        .stats-table td {
            font-family: monospace;
        }
        .maplibregl-popup-content {
            padding: 15px;
            font-size: 13px;
        }
        .popup-row {
            margin: 5px 0;
        }
        .popup-label {
            font-weight: 600;
            color: #555;
        }
        .rose-diagram-container {
            margin-top: 15px;
            padding: 15px;
            background: #f9f9f9;
            border-radius: 4px;
        }
        #roseDiagram {
            max-width: 100%;
            height: auto;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="control-panel">
        <h1>Building Shape Analysis</h1>
        
        <div class="upload-section">
            <input type="file" id="fileInput" accept=".geojson,.json" />
        </div>
        
        <button id="downloadBtn" disabled>Download CSV</button>
        
        <div id="statsSection" style="display: none;">
            <h2>Global Statistics</h2>
            <div id="statsContent"></div>
        </div>

        <div id="roseDiagramSection" style="display: none;" class="rose-diagram-container">
            <h2>Orientation Rose Diagram</h2>
            <canvas id="roseDiagram"></canvas>
        </div>
    </div>

    <script>
        // Initialize map with OpenFreeMap vector tiles
        const map = new maplibregl.Map({
            container: 'map',
            style: 'https://tiles.openfreemap.org/styles/liberty',
            center: [0, 0],
            zoom: 2
        });

        let buildingsData = [];
        let analyzedGeoJSON = null;
        let roseChart = null;

        // Hide unwanted POI layers after style loads
        map.on('load', () => {
            // Hide all POI icon layers
            const poiLayers = ['poi_r20', 'poi_r7', 'poi_r1', 'poi_transit'];
            poiLayers.forEach(layerId => {
                if (map.getLayer(layerId)) {
                    map.setLayoutProperty(layerId, 'visibility', 'none');
                }
            });

            // Add entrance points layer from openmaptiles source
            // First, we need to add a separate source for entrances since they're not in the default POI layer
            // We'll use Overpass API to fetch entrance data dynamically when the map moves
            map.on('moveend', fetchEntrances);
            fetchEntrances();
        });

        // Fetch entrance data from Overpass API
        async function fetchEntrances() {
            const zoom = map.getZoom();
            if (zoom < 16) {
                // Don't fetch entrances at low zoom levels
                if (map.getSource('entrances')) {
                    map.getSource('entrances').setData({
                        type: 'FeatureCollection',
                        features: []
                    });
                }
                return;
            }

            const bounds = map.getBounds();
            const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            
            // Overpass query for entrance=main and entrance=yes
            const query = `
                [out:json][timeout:25];
                (
                    node["entrance"="main"](${bbox});
                    node["entrance"="yes"](${bbox});
                );
                out geom;
            `;

            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: query
                });

                if (!response.ok) return;

                const data = await response.json();
                const features = data.elements.map(element => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [element.lon, element.lat]
                    },
                    properties: {
                        entrance: element.tags.entrance
                    }
                }));

                const geojson = {
                    type: 'FeatureCollection',
                    features: features
                };

                if (!map.getSource('entrances')) {
                    map.addSource('entrances', {
                        type: 'geojson',
                        data: geojson
                    });

                    map.addLayer({
                        id: 'entrance-points',
                        type: 'circle',
                        source: 'entrances',
                        paint: {
                            'circle-radius': 4,
                            'circle-color': '#000000',
                            'circle-stroke-width': 1,
                            'circle-stroke-color': '#ffffff'
                        }
                    });
                } else {
                    map.getSource('entrances').setData(geojson);
                }
            } catch (error) {
                console.log('Could not fetch entrances:', error);
            }
        }

        // Calculate accurate area in square meters accounting for latitude
        function calculateArea(polygon) {
            const area = turf.area(polygon);
            return area;
        }

        // Calculate roundness (circularity index)
        function calculateRoundness(polygon) {
            const area = turf.area(polygon);
            const perimeter = turf.length(turf.polygonToLine(polygon), {units: 'meters'});
            if (perimeter === 0) return 0;
            return (4 * Math.PI * area) / (perimeter * perimeter);
        }

        // Calculate centroid
        function calculateCentroid(polygon) {
            const centroid = turf.centroid(polygon);
            return centroid.geometry.coordinates;
        }

        // Calculate maximum distance from centroid (for arrow length)
        function calculateMaxAxisLength(polygon, centroid) {
            const coords = polygon.geometry.coordinates[0];
            let maxDist = 0;
            
            coords.forEach(coord => {
                const point = turf.point(coord);
                const center = turf.point(centroid);
                const dist = turf.distance(center, point, {units: 'meters'});
                if (dist > maxDist) {
                    maxDist = dist;
                }
            });
            
            return maxDist * 2; // Return twice the maximum distance
        }

        // Calculate major axis orientation using PCA
        function calculateOrientation(polygon) {
            const coords = polygon.geometry.coordinates[0];
            
            // Calculate centroid
            let sumX = 0, sumY = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                sumX += coords[i][0];
                sumY += coords[i][1];
            }
            const cx = sumX / (coords.length - 1);
            const cy = sumY / (coords.length - 1);
            
            // Calculate covariance matrix
            let cov_xx = 0, cov_yy = 0, cov_xy = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                const dx = coords[i][0] - cx;
                const dy = coords[i][1] - cy;
                cov_xx += dx * dx;
                cov_yy += dy * dy;
                cov_xy += dx * dy;
            }
            
            // Calculate angle from eigenvector
            const angle = 0.5 * Math.atan2(2 * cov_xy, cov_xx - cov_yy);
            
            // Convert to azimuth (0° = North, clockwise)
            let azimuth = 90 - (angle * 180 / Math.PI);
            if (azimuth < 0) azimuth += 360;
            if (azimuth >= 360) azimuth -= 360;
            
            return azimuth;
        }

        // Calculate statistics
        function calculateStats(values) {
            const sorted = [...values].sort((a, b) => a - b);
            const sum = values.reduce((a, b) => a + b, 0);
            const mean = sum / values.length;
            const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / values.length;
            const std = Math.sqrt(variance);
            
            return {
                count: values.length,
                sum: sum,
                mean: mean,
                std: std,
                min: sorted[0],
                max: sorted[sorted.length - 1]
            };
        }

        // Process GeoJSON
        function processGeoJSON(geojson) {
            buildingsData = [];
            
            const features = geojson.features.map((feature, idx) => {
                if (feature.geometry.type !== 'Polygon' && feature.geometry.type !== 'MultiPolygon') {
                    return null;
                }

                const polygon = feature.geometry.type === 'MultiPolygon' 
                    ? turf.polygon(feature.geometry.coordinates[0])
                    : feature;

                const area = calculateArea(polygon);
                const roundness = calculateRoundness(polygon);
                const centroid = calculateCentroid(polygon);
                const orientation = calculateOrientation(polygon);
                const axisLength = calculateMaxAxisLength(polygon, centroid);

                const analyzed = {
                    ...feature.properties,
                    area_sqm: area,
                    roundness: roundness,
                    centroid_lon: centroid[0],
                    centroid_lat: centroid[1],
                    orientation_deg: orientation,
                    axis_length_m: axisLength
                };

                buildingsData.push(analyzed);

                return {
                    ...feature,
                    properties: analyzed
                };
            }).filter(f => f !== null);

            analyzedGeoJSON = {
                type: 'FeatureCollection',
                features: features
            };

            return analyzedGeoJSON;
        }

        // Create arrow geometry with custom length
        function createArrowGeoJSON(geojson) {
            const arrows = {
                type: 'FeatureCollection',
                features: []
            };

            geojson.features.forEach(feature => {
                const centroid = [feature.properties.centroid_lon, feature.properties.centroid_lat];
                const orientation = feature.properties.orientation_deg;
                const length = feature.properties.axis_length_m;
                
                // Create arrow line with custom length
                const distance = length / 1000; // Convert meters to kilometers
                const bearing = orientation;
                const end = turf.destination(centroid, distance, bearing, {units: 'kilometers'});
                
                arrows.features.push({
                    type: 'Feature',
                    geometry: {
                        type: 'LineString',
                        coordinates: [centroid, end.geometry.coordinates]
                    },
                    properties: {
                        orientation: orientation
                    }
                });
            });

            return arrows;
        }

        // Create Rose Diagram
        function createRoseDiagram() {
            const orientations = buildingsData.map(b => b.orientation_deg);
            
            // Create 16 bins (22.5° each) for the rose diagram
            const binSize = 22.5;
            const numBins = 16;
            const bins = new Array(numBins).fill(0);
            
            orientations.forEach(angle => {
                const binIndex = Math.floor(((angle + binSize / 2) % 360) / binSize);
                bins[binIndex]++;
            });

            // Labels for compass directions
            const labels = ['N', 'NNE', 'NE', 'ENE', 'E', 'ESE', 'SE', 'SSE', 
                          'S', 'SSW', 'SW', 'WSW', 'W', 'WNW', 'NW', 'NNW'];

            // Destroy existing chart if present
            if (roseChart) {
                roseChart.destroy();
            }

            const ctx = document.getElementById('roseDiagram').getContext('2d');
            roseChart = new Chart(ctx, {
                type: 'polarArea',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Building Count',
                        data: bins,
                        backgroundColor: 'rgba(8, 136, 136, 0.6)',
                        borderColor: 'rgba(8, 136, 136, 1)',
                        borderWidth: 1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    scales: {
                        r: {
                            beginAtZero: true,
                            ticks: {
                                stepSize: Math.ceil(Math.max(...bins) / 5)
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: false
                        },
                        title: {
                            display: true,
                            text: 'Building Orientation Distribution'
                        }
                    }
                }
            });

            document.getElementById('roseDiagramSection').style.display = 'block';
        }

        // Display statistics
        function displayStats() {
            const areas = buildingsData.map(b => b.area_sqm);
            const roundness = buildingsData.map(b => b.roundness);
            const orientations = buildingsData.map(b => b.orientation_deg);

            const areaStats = calculateStats(areas);
            const roundnessStats = calculateStats(roundness);
            const orientationStats = calculateStats(orientations);

            const statsHTML = `
                <table class="stats-table">
                    <tr><th>Metric</th><th>Area (m²)</th><th>Roundness</th><th>Orientation (°)</th></tr>
                    <tr><td>Count</td><td>${areaStats.count}</td><td>${roundnessStats.count}</td><td>${orientationStats.count}</td></tr>
                    <tr><td>Sum</td><td>${areaStats.sum.toFixed(2)}</td><td>-</td><td>-</td></tr>
                    <tr><td>Mean</td><td>${areaStats.mean.toFixed(2)}</td><td>${roundnessStats.mean.toFixed(4)}</td><td>${orientationStats.mean.toFixed(2)}</td></tr>
                    <tr><td>Std Dev</td><td>${areaStats.std.toFixed(2)}</td><td>${roundnessStats.std.toFixed(4)}</td><td>${orientationStats.std.toFixed(2)}</td></tr>
                    <tr><td>Min</td><td>${areaStats.min.toFixed(2)}</td><td>${roundnessStats.min.toFixed(4)}</td><td>${orientationStats.min.toFixed(2)}</td></tr>
                    <tr><td>Max</td><td>${areaStats.max.toFixed(2)}</td><td>${roundnessStats.max.toFixed(4)}</td><td>${orientationStats.max.toFixed(2)}</td></tr>
                </table>
            `;

            document.getElementById('statsContent').innerHTML = statsHTML;
            document.getElementById('statsSection').style.display = 'block';
        }

        // Add layers to map
        function addLayersToMap(geojson) {
            // Remove existing layers if present
            if (map.getLayer('buildings')) map.removeLayer('buildings');
            if (map.getLayer('buildings-outline')) map.removeLayer('buildings-outline');
            if (map.getLayer('arrows')) map.removeLayer('arrows');
            if (map.getSource('buildings')) map.removeSource('buildings');
            if (map.getSource('arrows')) map.removeSource('arrows');

            // Add buildings source and layers
            map.addSource('buildings', {
                type: 'geojson',
                data: geojson
            });

            map.addLayer({
                id: 'buildings',
                type: 'fill',
                source: 'buildings',
                paint: {
                    'fill-color': '#088',
                    'fill-opacity': 0.4
                }
            });

            map.addLayer({
                id: 'buildings-outline',
                type: 'line',
                source: 'buildings',
                paint: {
                    'line-color': '#088',
                    'line-width': 2
                }
            });

            // Add arrows
            const arrows = createArrowGeoJSON(geojson);
            map.addSource('arrows', {
                type: 'geojson',
                data: arrows
            });

            map.addLayer({
                id: 'arrows',
                type: 'line',
                source: 'arrows',
                paint: {
                    'line-color': '#ff0000',
                    'line-width': 2
                }
            });

            // Fit map to buildings
            const bbox = turf.bbox(geojson);
            map.fitBounds(bbox, { padding: 50 });

            // Add click handler
            map.on('click', 'buildings', (e) => {
                const properties = e.features[0].properties;
                
                let html = '<div>';
                if (properties.name) {
                    html += `<div class="popup-row"><span class="popup-label">Name:</span> ${properties.name}</div>`;
                }
                html += `
                    <div class="popup-row"><span class="popup-label">Area:</span> ${parseFloat(properties.area_sqm).toFixed(2)} m²</div>
                    <div class="popup-row"><span class="popup-label">Roundness:</span> ${parseFloat(properties.roundness).toFixed(4)}</div>
                    <div class="popup-row"><span class="popup-label">Centroid:</span> ${parseFloat(properties.centroid_lat).toFixed(6)}, ${parseFloat(properties.centroid_lon).toFixed(6)}</div>
                    <div class="popup-row"><span class="popup-label">Orientation:</span> ${parseFloat(properties.orientation_deg).toFixed(2)}°</div>
                `;
                html += '</div>';

                new maplibregl.Popup()
                    .setLngLat(e.lngLat)
                    .setHTML(html)
                    .addTo(map);
            });

            map.on('mouseenter', 'buildings', () => {
                map.getCanvas().style.cursor = 'pointer';
            });

            map.on('mouseleave', 'buildings', () => {
                map.getCanvas().style.cursor = '';
            });
        }

        // File upload handler
        document.getElementById('fileInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
                try {
                    const geojson = JSON.parse(event.target.result);
                    const processed = processGeoJSON(geojson);
                    addLayersToMap(processed);
                    displayStats();
                    createRoseDiagram();
                    document.getElementById('downloadBtn').disabled = false;
                } catch (error) {
                    alert('Error processing GeoJSON: ' + error.message);
                }
            };
            reader.readAsText(file);
        });

        // CSV download handler
        document.getElementById('downloadBtn').addEventListener('click', () => {
            if (buildingsData.length === 0) return;

            // Get all unique keys
            const allKeys = new Set();
            buildingsData.forEach(row => {
                Object.keys(row).forEach(key => allKeys.add(key));
            });

            const keys = Array.from(allKeys);
            
            // Create CSV
            let csv = keys.join(',') + '\n';
            buildingsData.forEach(row => {
                const values = keys.map(key => {
                    const value = row[key];
                    if (value === undefined || value === null) return '';
                    if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
                        return '"' + value.replace(/"/g, '""') + '"';
                    }
                    return value;
                });
                csv += values.join(',') + '\n';
            });

            // Download
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'building_analysis.csv';
            a.click();
            URL.revokeObjectURL(url);
        });
    </script>
</body>
</html>